mam taki main.py:
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from config import settings
from api import users, locations
from api import groups
from api import schedules
from api import priceusers

import logging

# Wy≈ÇƒÖcz debugowanie pymongo i innych bibliotek
logging.getLogger("pymongo").setLevel(logging.WARNING)
logging.getLogger("motor").setLevel(logging.WARNING)
logging.getLogger("asyncio").setLevel(logging.WARNING)
logging.getLogger("uvicorn.access").setLevel(logging.INFO)


app = FastAPI(
    title="Location Management API",
    description="API for managing users and locations with devices",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Database connection
@app.on_event("startup")
async def startup_db_client():
    try:
        app.mongodb_client = AsyncIOMotorClient(settings.MONGODB_URI)
        app.mongodb = app.mongodb_client[settings.DATABASE_NAME]
        # Test connection
        await app.mongodb_client.admin.command('ping')
        print(f"‚úÖ Connected to MongoDB at {settings.MONGODB_URI}")
        print(f"üìÅ Using database: {settings.DATABASE_NAME}")
    except Exception as e:
        print(f"‚ùå Failed to connect to MongoDB: {e}")
        print(f"üîß Check your MONGODB_URI in .env: {settings.MONGODB_URI}")
        raise e

@app.on_event("shutdown")
async def shutdown_db_client():
    app.mongodb_client.close()

# Include routers
app.include_router(users.router, prefix="/api/users", tags=["users"])
app.include_router(locations.router, prefix="/api/locations", tags=["locations"])
app.include_router(groups.router, prefix="/api", tags=["groups"])
app.include_router(schedules.router, prefix="/api")
app.include_router(priceusers.router, prefix="/api/priceusers", tags=["priceusers"])

@app.get("/")
async def root():
    return {"message": "Location Management API is running"}

@app.get("/health")
async def health_check():
    try:
        # Test database connection
        await app.mongodb_client.admin.command('ping')
        return {
            "status": "healthy",
            "database": "connected",
            "mongodb_uri": settings.MONGODB_URI.split('@')[-1] if '@' in settings.MONGODB_URI else settings.MONGODB_URI
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "database": "disconnected",
            "error": str(e)
        }



@app.on_event("startup")
async def print_routes():
    print("\n--- Registered Routes ---")
    for route in app.routes:
        print(f"Route: {route.path}")

        # ############

from fastapi.responses import JSONResponse
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from config import settings
from api import users, locations
from bson import json_util
import json


@app.get("/dump", tags=["debug"])
async def dump_database(request: Request):
    """
    Returns the entire database content as JSON.
    ‚ö†Ô∏è Use only for debugging! Disable in production!
    """
    db = request.app.mongodb
    dump = {}
    try:
        collections = await db.list_collection_names()
        for collection_name in collections:
            collection = db[collection_name]
            documents = []
            async for doc in collection.find():
                documents.append(doc)
            dump[collection_name] = documents

        # Use bson.json_util to handle ObjectId and datetime serialization
        return JSONResponse(content=json.loads(json_util.dumps(dump)))

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error dumping database: {str(e)}"
        )


        # ############


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

mam taki models.py:
from pydantic import BaseModel, Field, EmailStr
from typing import Optional, List, Dict
from bson import ObjectId
from enum import Enum

class PyObjectId(ObjectId):
    @classmethod
    def __get_pydantic_core_schema__(
            cls, _source_type, _handler
    ):
        from pydantic_core import core_schema
        return core_schema.json_or_python_schema(
            json_schema=core_schema.str_schema(),
            python_schema=core_schema.union_schema([
                core_schema.is_instance_schema(ObjectId),
                core_schema.chain_schema([
                    core_schema.str_schema(),
                    core_schema.no_info_plain_validator_function(cls.validate),
                ])
            ]),
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda x: str(x)
            ),
        )

    @classmethod
    def validate(cls, v):
        if isinstance(v, ObjectId):
            return v
        if isinstance(v, str):
            if not ObjectId.is_valid(v):
                raise ValueError("Invalid ObjectId")
            return ObjectId(v)
        raise ValueError("Invalid ObjectId")


# Enum to define user types
class UserType(str, Enum):
    admin = "admin"
    user = "user"


# Device model
class Device(BaseModel):
    id: Optional[str] = Field(None, alias="_id", description="Unique ID of the device")
    clientId: str = Field(..., description="Unique device identifier")
    clientName: str = Field(..., description="Device name")
    ip: Optional[str] = Field("", description="Device IP address")
    photo: Optional[str] = Field(None, description="Base64 encoded photo")
    video: Optional[str] = Field(None, description="Base64 encoded video")
    changed: Optional[str] = Field("false", description="Has device been changed")
    thumbnail: Optional[str] = Field(None, description="Path to thumbnail")
    groups: Optional[List[PyObjectId]] = Field(default_factory=list, description="Lista ID grup")
    isOnline: Optional[bool] = Field(default=None, description="Czy urządzenie jest online")  # ⬅️ NOWE

    class Config:
        allow_population_by_field_name = True
        json_encoders = {ObjectId: str}


class DeviceUpdate(BaseModel):
    client_id: Optional[str] = None
    client_name: Optional[str] = None
    photo: Optional[str] = None
    video: Optional[str] = None
    ip: Optional[str] = None
    thumbnail: Optional[str] = None  # ⬅️ DODANE



class DeviceMediaUpdate(BaseModel):
    photo: Optional[str] = None
    video: Optional[str] = None




# LocationData model
class LocationData(BaseModel):
    name: str = Field(..., description="Location name")
    address: str = Field(..., description="Location address")
    devices: List[Device] = Field(default_factory=list, description="List of devices")


# Location model
class Location(BaseModel):
    id: Optional[PyObjectId] = Field(default_factory=PyObjectId, alias="_id")
    locations: Dict[str, LocationData]  # A dictionary of location names to LocationData

    class Config:
        json_encoders = {
            ObjectId: str  # Convert ObjectId to string before returning in response
        }


# User model
class User(BaseModel):
    id: Optional[PyObjectId] = Field(default_factory=PyObjectId, alias="_id")
    login: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=6)
    user_type: UserType = Field(default=UserType.user)

    class Config:
        json_encoders = {
            ObjectId: str
        }


# Model for creating a new User (excluding ID and automatic fields)
class UserCreate(BaseModel):
    login: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=6)
    user_type: UserType = Field(default=UserType.user)

    class Config:
        json_encoders = {
            ObjectId: str  # Ensure ObjectId is serialized properly
        }



# Response model for User
class UserResponse(BaseModel):
    id: str = Field(alias="_id")
    login: str
    user_type: UserType

    class Config:
        json_encoders = {
            ObjectId: str
        }


# Model for the response when creating a new Location
class LocationResponse(BaseModel):
    id: str = Field(alias="_id")
    name: str
    address: str
    devices: List[Device]

    class Config:
        json_encoders = {
            ObjectId: str  # Convert ObjectId to string before returning in response
        }


# Model for creating a new Location
class LocationCreate(BaseModel):
    name: str
    address: str
    devices: List[Device] = []  # Optional, defaults to an empty list

    class Config:
        json_encoders = {
            ObjectId: str
        }


from pydantic import BaseModel
from typing import List

# Model dla ID lokalizacji
class LocationIdsRequest(BaseModel):
    location_ids: List[str]

class UserDevicesResponse(BaseModel):
    user_id: str
    login: str
    devices: List[Device]


class PriceUser(BaseModel):
    id: Optional[PyObjectId] = Field(default_factory=PyObjectId, alias="_id")
    first_name: str
    last_name: str
    email: str
    locationName: str
    locationId: str
    passwordHash: str

    class Config:
        allow_population_by_field_name = True
        json_encoders = {ObjectId: str}

class PriceUserCreate(BaseModel):
    first_name: str
    last_name: str
    email: str
    password: str
    locationName: str
    locationId: Optional[str]

class PriceUserLogin(BaseModel):
    email: str
    password: str

class PriceUserUpdate(BaseModel):
    first_name: Optional[str]
    last_name: Optional[str]
    email: Optional[EmailStr]
    password: Optional[str]
    locationName: Optional[str]
    locationId: Optional[str]  # ← DODAJ TO

class PriceUserResponse(BaseModel):
    id: str = Field(alias="_id")
    first_name: str
    last_name: str
    email: str
    locationName: str
    locationId: str

    class Config:
        json_encoders = {ObjectId: str}





mam taki api.py:

from fastapi import FastAPI, HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import List
from bson import ObjectId
from datetime import datetime

from models import (
    UserCreate, UserUpdate, UserResponse, LoginRequest, LoginResponse,
    LocationCreate, LocationUpdate, LocationResponse, Device, DeviceUpdate
)
from config import users_collection, locations_collection
from utils import hash_password, verify_password, user_helper, location_helper, validate_object_id

# Inicjalizacja FastAPI
app = FastAPI(
    title="User & Location Management API",
    description="API do zarządzania użytkownikami i lokalizacjami z urządzeniami",
    version="1.0.0"
)

security = HTTPBearer()


# Dependency do weryfikacji tokena (uproszczona wersja)
async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Pobiera aktualnego użytkownika na podstawie tokena"""
    # Tu powinieneś zaimplementować właściwą weryfikację JWT
    # Na razie zwracamy None - należy to dostosować do swoich potrzeb
    return None


# ==================== ENDPOINTS GŁÓWNE ====================

@app.get("/")
async def root():
    """Endpoint główny"""
    return {"message": "User & Location Management API"}


@app.get("/health")
async def health_check():
    """Sprawdzenie stanu aplikacji"""
    return {"status": "healthy"}


# ==================== ENDPOINTS UŻYTKOWNIKÓW ====================

@app.post("/users/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate):
    """Tworzy nowego użytkownika"""
    # Sprawdź czy użytkownik już istnieje
    existing_user = await users_collection.find_one({"login": user.login})
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Użytkownik z tym loginem już istnieje"
        )

    # Haszuj hasło
    hashed_password = hash_password(user.password)

    # Przygotuj dane do zapisu
    user_data = {
        "login": user.login,
        "password": hashed_password,
        "type": user.user_type,
        "created_at": datetime.utcnow()
    }

    # Zapisz do bazy
    result = await users_collection.insert_one(user_data)

    # Pobierz zapisanego użytkownika
    created_user = await users_collection.find_one({"_id": result.inserted_id})

    return UserResponse(**user_helper(created_user))


@app.get("/users/", response_model=List[UserResponse])
async def get_users():
    """Pobiera listę wszystkich użytkowników"""
    users = []
    async for user in users_collection.find():
        users.append(UserResponse(**user_helper(user)))
    return users


@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: str):
    """Pobiera użytkownika po ID"""
    if not validate_object_id(user_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    user = await users_collection.find_one({"_id": ObjectId(user_id)})
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Użytkownik nie został znaleziony"
        )

    return UserResponse(**user_helper(user))


@app.put("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: str, user_update: UserUpdate):
    """Aktualizuje użytkownika"""
    if not validate_object_id(user_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    # Przygotuj dane do aktualizacji
    update_data = {}
    if user_update.login is not None:
        # Sprawdź czy nowy login nie jest już zajęty
        existing_user = await users_collection.find_one({
            "login": user_update.login,
            "_id": {"$ne": ObjectId(user_id)}
        })
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Login już zajęty"
            )
        update_data["login"] = user_update.login

    if user_update.password is not None:
        update_data["password"] = hash_password(user_update.password)

    if user_update.user_type is not None:
        update_data["type"] = user_update.user_type

    if not update_data:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Brak danych do aktualizacji"
        )

    # Aktualizuj użytkownika
    result = await users_collection.update_one(
        {"_id": ObjectId(user_id)},
        {"$set": update_data}
    )

    if result.matched_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Użytkownik nie został znaleziony"
        )

    # Pobierz zaktualizowanego użytkownika
    updated_user = await users_collection.find_one({"_id": ObjectId(user_id)})
    return UserResponse(**user_helper(updated_user))


@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(user_id: str):
    """Usuwa użytkownika"""
    if not validate_object_id(user_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    result = await users_collection.delete_one({"_id": ObjectId(user_id)})

    if result.deleted_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Użytkownik nie został znaleziony"
        )


# ==================== ENDPOINTS AUTORYZACJI ====================

@app.post("/login/", response_model=LoginResponse)
async def login(login_data: LoginRequest):
    """Loguje użytkownika"""
    user = await users_collection.find_one({"login": login_data.login})
    if not user or not verify_password(login_data.password, user["password"]):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Nieprawidłowy login lub hasło"
        )

    # Tu powinieneś wygenerować JWT token
    # Na razie zwracamy podstawowe informacje o użytkowniku
    return LoginResponse(
        message="Zalogowano pomyślnie",
        user=UserResponse(**user_helper(user)),
        token="your_jwt_token_here"  # Zastąp prawdziwym tokenem JWT
    )


# ==================== ENDPOINTS LOKALIZACJI ====================

@app.post("/locations/", response_model=LocationResponse, status_code=status.HTTP_201_CREATED)
async def create_location(location: LocationCreate):
    """Tworzy nową lokalizację"""
    location_data = {
        "name": location.name,
        "address": location.address,
        "devices": [device.dict(by_alias=True) for device in location.devices],
        "created_at": datetime.utcnow(),
        "updated_at": datetime.utcnow()
    }

    result = await locations_collection.insert_one(location_data)
    created_location = await locations_collection.find_one({"_id": result.inserted_id})

    return LocationResponse(**location_helper(created_location))


@app.get("/locations/", response_model=List[LocationResponse])
async def get_locations():
    """Pobiera listę wszystkich lokalizacji"""
    locations = []
    async for location in locations_collection.find():
        locations.append(LocationResponse(**location_helper(location)))
    return locations


@app.get("/locations/{location_id}", response_model=LocationResponse)
async def get_location(location_id: str):
    """Pobiera lokalizację po ID"""
    if not validate_object_id(location_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    location = await locations_collection.find_one({"_id": ObjectId(location_id)})
    if not location:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Lokalizacja nie została znaleziona"
        )

    return LocationResponse(**location_helper(location))


@app.put("/locations/{location_id}", response_model=LocationResponse)
async def update_location(location_id: str, location_update: LocationUpdate):
    """Aktualizuje lokalizację"""
    if not validate_object_id(location_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    update_data = {"updated_at": datetime.utcnow()}

    if location_update.name is not None:
        update_data["name"] = location_update.name

    if location_update.address is not None:
        update_data["address"] = location_update.address

    if location_update.devices is not None:
        update_data["devices"] = [device.dict(by_alias=True) for device in location_update.devices]

    result = await locations_collection.update_one(
        {"_id": ObjectId(location_id)},
        {"$set": update_data}
    )

    if result.matched_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Lokalizacja nie została znaleziona"
        )

    updated_location = await locations_collection.find_one({"_id": ObjectId(location_id)})
    return LocationResponse(**location_helper(updated_location))


@app.delete("/locations/{location_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_location(location_id: str):
    """Usuwa lokalizację"""
    if not validate_object_id(location_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    result = await locations_collection.delete_one({"_id": ObjectId(location_id)})

    if result.deleted_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Lokalizacja nie została znaleziona"
        )


# ==================== ENDPOINTS URZĄDZEŃ ====================

@app.post("/locations/{location_id}/devices", response_model=LocationResponse)
async def add_device_to_location(location_id: str, device: Device):
    """Dodaje urządzenie do lokalizacji"""
    if not validate_object_id(location_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    location = await locations_collection.find_one({"_id": ObjectId(location_id)})
    if not location:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Lokalizacja nie została znaleziona"
        )

    # Sprawdź czy urządzenie o takim client_id już istnieje
    existing_devices = location.get("devices", [])
    for existing_device in existing_devices:
        if existing_device.get("clientId") == device.client_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Urządzenie o takim clientId już istnieje w tej lokalizacji"
            )

    # Dodaj nowe urządzenie
    new_device = device.dict(by_alias=True)

    result = await locations_collection.update_one(
        {"_id": ObjectId(location_id)},
        {
            "$push": {"devices": new_device},
            "$set": {"updated_at": datetime.utcnow()}
        }
    )

    updated_location = await locations_collection.find_one({"_id": ObjectId(location_id)})
    return LocationResponse(**location_helper(updated_location))


@app.put("/locations/{location_id}/devices/{client_id}", response_model=LocationResponse)
async def update_device_in_location(location_id: str, client_id: str, device_update: DeviceUpdate):
    """Aktualizuje urządzenie w lokalizacji"""
    if device_update.ip is not None:
        device["ip"] = device_update.ip
    if not validate_object_id(location_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    location = await locations_collection.find_one({"_id": ObjectId(location_id)})
    if not location:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Lokalizacja nie została znaleziona"
        )

    # Znajdź i zaktualizuj urządzenie
    devices = location.get("devices", [])
    device_found = False

    for i, device in enumerate(devices):
        if device.get("clientId") == client_id:
            device_found = True
            # Aktualizuj tylko te pola, które zostały podane
            if device_update.client_id is not None:
                device["clientId"] = device_update.client_id
            if device_update.client_name is not None:
                device["clientName"] = device_update.client_name
            if device_update.photo is not None:
                device["photo"] = device_update.photo
            if device_update.video is not None:
                device["video"] = device_update.video
            break

    if not device_found:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Urządzenie nie zostało znalezione"
        )

    # Zapisz zmiany
    await locations_collection.update_one(
        {"_id": ObjectId(location_id)},
        {
            "$set": {
                "devices": devices,
                "updated_at": datetime.utcnow()
            }
        }
    )

    updated_location = await locations_collection.find_one({"_id": ObjectId(location_id)})
    return LocationResponse(**location_helper(updated_location))


@app.delete("/locations/{location_id}/devices/{client_id}", response_model=LocationResponse)
async def remove_device_from_location(location_id: str, client_id: str):
    """Usuwa urządzenie z lokalizacji"""
    if not validate_object_id(location_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nieprawidłowy format ID"
        )

    result = await locations_collection.update_one(
        {"_id": ObjectId(location_id)},
        {
            "$pull": {"devices": {"clientId": client_id}},
            "$set": {"updated_at": datetime.utcnow()}
        }
    )

    if result.matched_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Lokalizacja nie została znaleziona"
        )

    updated_location = await locations_collection.find_one({"_id": ObjectId(location_id)})
    if not updated_location:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Lokalizacja nie została znaleziona"
        )

    return LocationResponse(**location_helper(updated_location))


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)


mam taki api/locations.py:

from fastapi import APIRouter, HTTPException, Depends, status, Request
from typing import List
from models import Location, LocationCreate, LocationResponse, Device
from bson import ObjectId
import logging

from fastapi import APIRouter, HTTPException, Depends, status, Request
from models import Device, LocationCreate, LocationResponse
from bson import ObjectId
import logging


# Konfiguracja loggera
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

router = APIRouter()

# Function to get the database
def get_database(request: Request):
    return request.app.mongodb

# Endpoint to create a new location (single location)
@router.post("/", response_model=LocationResponse, status_code=status.HTTP_201_CREATED)
async def create_location(location: LocationCreate, db=Depends(get_database)):
    """
    Create a single location document
    """
    try:
        # Prepare location data
        location_data = {
            "id": str(ObjectId()),  # Generate unique ID for each location
            "name": location.name,
            "address": location.address,
            "devices": location.devices,
        }

        # Insert the location document in the locations collection
        result = await db["locations"].insert_one(location_data)

        # Get the created location
        created_location = await db["locations"].find_one({"_id": result.inserted_id})
        created_location["_id"] = str(created_location["_id"])

        return LocationResponse(**created_location)

    except Exception as e:
        logger.error(f"Error creating location: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating location: {str(e)}"
        )


# Function to get the database
def get_database(request: Request):
    return request.app.mongodb

# Endpoint to add a device to a location
# api.py

@router.post("/{location_id}/devices", status_code=status.HTTP_201_CREATED)
async def add_device_to_location(location_id: str, device: Device, db=Depends(get_database)):
    """
    Add a device to a location
    """
    try:
        if not ObjectId.is_valid(location_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid location ID format"
            )

        location = await db["locations"].find_one({"_id": ObjectId(location_id)})
        if not location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Location not found"
            )

        # Add unique ID to the device if not already present
        device_dict = {
            "_id": str(ObjectId()),
            "clientId": device.clientId,
            "clientName": device.clientName,
            "ip": device.ip or "",
            "photo": device.photo,
            "video": device.video,
            "changed": "false",
            "thumbnail": None,
            "isOnline": True
        }




        # Add the "changed" key with the value "false" to the device
        device_dict["changed"] = "false"
        
        # Add unique _id to the device
        device_dict["_id"] = str(ObjectId())  # Assign a unique ID to the device

        # Check if device already exists
        for existing_device in location.get("devices", []):
            if existing_device.get("clientId") == device.clientId:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Device with this clientId already exists in this location"
                )

        # Add the new device to the list of devices
        if "devices" not in location:
            location["devices"] = []
        
        location["devices"].append(device_dict)

        # Update the location in the database
        result = await db["locations"].update_one(
            {"_id": ObjectId(location_id)},
            {"$set": {"devices": location["devices"]}}
        )

        if result.matched_count == 0:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Failed to update location"
            )

        # Convert _id and devices' _id to string before returning
        location["_id"] = str(location["_id"])
        for device in location["devices"]:
            device["_id"] = str(device["_id"])

        return {"message": "Device added successfully", "location": location}

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error adding device to location: {str(e)}"
        )




# Endpoint to get all locations
@router.get("/", response_model=List[LocationResponse])
async def get_locations(db=Depends(get_database)):
    """
    Get all location documents
    """
    try:
        locations = []
        async for location in db["locations"].find():
            locations.append(LocationResponse(**location))
        return locations
    except Exception as e:
        logger.error(f"Error fetching locations: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching locations: {str(e)}"
        )

# Endpoint to get a specific location by ID
@router.get("/{location_id}", response_model=LocationResponse)
async def get_location(location_id: str, db=Depends(get_database)):
    """
    Get location by ID
    """
    try:
        # Convert string ID to ObjectId
        if not ObjectId.is_valid(location_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid location ID format"
            )

        location = await db["locations"].find_one({"_id": ObjectId(location_id)})
        if not location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Location not found"
            )

        # Convert _id (ObjectId) to string before returning as a response
        location["_id"] = str(location["_id"])

        return LocationResponse(**location)

    except Exception as e:
        logger.error(f"Error fetching location: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching location: {str(e)}"
        )


@router.delete("/delete-all", status_code=status.HTTP_204_NO_CONTENT)
async def delete_all_locations(db=Depends(get_database)):
    """
    Usuwa wszystkie lokalizacje z bazy danych
    """
    try:
        # Usuwanie wszystkich dokumentów w kolekcji "locations"
        result = await db["locations"].delete_many({})

        # Jeśli nie usunięto żadnych dokumentów, zwróć 404
        if result.deleted_count == 0:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Brak lokalizacji do usunięcia"
            )

        return {"message": "Wszystkie lokalizacje zostały usunięte"}

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting all locations: {str(e)}"
        )


@router.delete("/{location_id}/devices/{device_id}", status_code=status.HTTP_204_NO_CONTENT)
async def remove_device_from_location(location_id: str, device_id: str, db=Depends(get_database)):
    """
    Remove a device from a location by device _id
    """
    try:
        if not ObjectId.is_valid(location_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid location ID format"
            )

        if not ObjectId.is_valid(device_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid device ID format"
            )

        location = await db["locations"].find_one({"_id": ObjectId(location_id)})
        if not location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Location not found"
            )

        # Find and remove the device with the provided device_id
        devices = location.get("devices", [])
        updated_devices = [device for device in devices if str(device["_id"]) != device_id]

        if len(devices) == len(updated_devices):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Device not found"
            )

        # Update the location with the new list of devices
        result = await db["locations"].update_one(
            {"_id": ObjectId(location_id)},
            {"$set": {"devices": updated_devices}}
        )

        if result.matched_count == 0:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Failed to update location"
            )

        return {"message": "Device removed successfully"}

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error removing device from location: {str(e)}"
        )


@router.get("/{location_id}/devices", response_model=List[Device])
async def get_devices_from_location(location_id: str, db=Depends(get_database)):
    """
    Get all devices from a specific location by its ID
    """
    try:
        if not ObjectId.is_valid(location_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid location ID format"
            )

        location = await db["locations"].find_one({"_id": ObjectId(location_id)})
        if not location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Location not found"
            )

        devices = location.get("devices", [])

        # Zamień _id każdego urządzenia na string
        for device in devices:
            if "_id" in device and isinstance(device["_id"], ObjectId):
                device["_id"] = str(device["_id"])

        return devices

    except Exception as e:
        logger.error(f"Error fetching devices from location: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching devices from location: {str(e)}"
        )

@router.put("/{location_id}/devices/{device_id}/photo", status_code=200)
async def update_device_photo(location_id: str, device_id: str, body: dict, db=Depends(get_database)):
    """
    Update the photo for a specific device in a location
    """
    photo = body.get("photo")
    if not photo:
        raise HTTPException(status_code=400, detail="Missing photo")

    return await _update_device_field(location_id, device_id, {"photo": photo}, db)


@router.put("/{location_id}/devices/{device_id}/video", status_code=200)
async def update_device_video(location_id: str, device_id: str, body: dict, db=Depends(get_database)):
    """
    Update the video for a specific device in a location
    """
    video = body.get("video")
    if not video:
        raise HTTPException(status_code=400, detail="Missing video")

    return await _update_device_field(location_id, device_id, {"video": video}, db)


async def _update_device_field(location_id: str, device_id: str, update_fields: dict, db):
    if not ObjectId.is_valid(location_id) or not ObjectId.is_valid(device_id):
        raise HTTPException(status_code=400, detail="Invalid ID format")

    location = await db["locations"].find_one({"_id": ObjectId(location_id)})
    if not location:
        raise HTTPException(status_code=404, detail="Location not found")

    devices = location.get("devices", [])
    updated = False

    for device in devices:
        if str(device["_id"]) == device_id:
            device.update(update_fields)
            updated = True
            break

    if not updated:
        raise HTTPException(status_code=404, detail="Device not found")

    await db["locations"].update_one(
        {"_id": ObjectId(location_id)},
        {"$set": {"devices": devices}}
    )

    return {"message": "Device updated successfully", "updated_fields": update_fields}


@router.delete("/{location_id}/devices/{device_id}/delete-files", status_code=200)
async def clear_device_files(location_id: str, device_id: str, db=Depends(get_database)):
    """
    Nadpisuje pola photo i video pustym stringiem dla danego urządzenia
    """
    if not ObjectId.is_valid(location_id) or not ObjectId.is_valid(device_id):
        raise HTTPException(status_code=400, detail="Invalid ID format")

    location = await db["locations"].find_one({"_id": ObjectId(location_id)})
    if not location:
        raise HTTPException(status_code=404, detail="Location not found")

    devices = location.get("devices", [])
    updated = False

    for device in devices:
        if str(device.get("_id")) == device_id:
            device["photo"] = ""
            device["video"] = ""
            updated = True
            break

    if not updated:
        raise HTTPException(status_code=404, detail="Device not found")

    await db["locations"].update_one(
        {"_id": ObjectId(location_id)},
        {"$set": {"devices": devices}}
    )

    return {
        "message": "File fields cleared (set to empty string)",
        "device_id": device_id
    }



@router.put("/{location_id}/devices/{device_id}/changed-true", status_code=200)
async def set_device_changed_true(location_id: str, device_id: str, db=Depends(get_database)):
    """
    Ustawia flagę 'changed' na 'true' dla danego urządzenia
    """
    return await _update_device_field(location_id, device_id, {"changed": "true"}, db)


@router.put("/{location_id}/devices/{device_id}/changed-false", status_code=200)
async def set_device_changed_false(location_id: str, device_id: str, db=Depends(get_database)):
    """
    Ustawia flagę 'changed' na 'false' dla danego urządzenia
    """
    return await _update_device_field(location_id, device_id, {"changed": "false"}, db)


from fastapi import UploadFile, File
import os
from pathlib import Path
import shutil

# Konfiguracja ścieżki do przechowywania plików
UPLOAD_DIR = ""  # Główny katalog dla przesyłanych plików

@router.post("/{location_id}/upload-file/")
async def upload_file_to_location(
    location_id: str,
    file: UploadFile = File(...),
    db=Depends(get_database)
):
    try:
        # Validate location ID
        if not ObjectId.is_valid(location_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid location ID format"
            )

        # Check if location exists
        location = await db["locations"].find_one({"_id": ObjectId(location_id)})
        if not location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Location not found"
            )

        # Create upload directory if it doesn't exist
        location_dir = Path(UPLOAD_DIR) / location_id
        location_dir.mkdir(parents=True, exist_ok=True)

        # Save the file
        file_path = location_dir / file.filename
        
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        # Return the path where the file was saved
        return {
            "message": "File uploaded successfully",
            "location_id": location_id,
            "filename": file.filename,
            "file_path": str(file_path),
            "file_size": os.path.getsize(file_path)
        }

    except Exception as e:
        logger.error(f"Error uploading file: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error uploading file: {str(e)}"
        )


from fastapi.responses import FileResponse

@router.get("/{location_id}/files/{filename}")
async def get_file_from_location(
    location_id: str,
    filename: str
):
    """
    Download a file from a specific location
    """
    try:
        file_path = Path(UPLOAD_DIR) / location_id / filename
        
        if not file_path.exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="File not found"
            )

        return FileResponse(file_path)

    except Exception as e:
        logger.error(f"Error retrieving file: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error retrieving file: {str(e)}"
        )



@router.get("/{location_id}/files/")
async def list_files_in_location(location_id: str):
    """
    List all files in a specific location
    """
    try:
        location_dir = Path(UPLOAD_DIR) / location_id
        
        if not location_dir.exists():
            return {"files": []}

        files = [f.name for f in location_dir.iterdir() if f.is_file()]
        return {"files": files}

    except Exception as e:
        logger.error(f"Error listing files: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error listing files: {str(e)}"
        )



# Dodaj te importy na górze pliku z endpointami FastAPI
from PIL import Image
import io
import asyncio
import os
import subprocess
from pathlib import Path
from fastapi.responses import Response, FileResponse # Dodaj FileResponse
from fastapi import HTTPException, status # Upewnij się, że masz te importy dla błędów HTTP
from bson import ObjectId # Jeśli używasz MongoDB, upewnij się, że masz to zaimportowane

# --- WAŻNE --- Upewnij się, że UPLOAD_DIR jest zdefiniowany i ma sensowną ścieżkę
# PRZYKŁAD: UPLOAD_DIR = Path("uploads") # To stworzy katalog 'uploads' w miejscu, gdzie uruchamiasz skrypt
# UPEWNIJ SIĘ, ŻE TEN KATALOG ISTNIEJE LUB JEST TWORZONY PRZY STARCIE APLIKACJI
UPLOAD_DIR = Path("") # <-- Popraw lub zweryfikuj tę linię

# Pamiętaj o importowaniu loggera, jeśli go używasz
# from loguru import logger # Przykładowy logger

@router.get("/{location_id}/files/{filename}/thumbnail")
async def get_file_thumbnail(
    location_id: str,
    filename: str,
    size: int = 128  # Rozmiar miniaturki (kwadrat)
):
    """
    Zwraca miniaturkę pliku (obrazu lub klatki z wideo).
    """
    try:
        # Możesz dodać walidację location_id, jeśli jest to wymagane dla twojej logiki
        # if not ObjectId.is_valid(location_id):
        #     raise HTTPException(
        #         status_code=status.HTTP_400_BAD_REQUEST,
        #         detail="Invalid location ID format"
        #     )

        file_path = UPLOAD_DIR / location_id / filename
        # print(f"Attempting to get thumbnail for: {file_path}") # Dodaj to do debugowania

        if not file_path.exists():
            # print(f"File not found at: {file_path}") # Dodaj to do debugowania
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="File not found"
            )

        file_extension = file_path.suffix.lower()

        if file_extension in [".jpg", ".jpeg", ".png", ".gif", ".bmp"]:
            # Przetwarzanie obrazów
            img = Image.open(file_path)
            img.thumbnail((size, size))
            img_byte_arr = io.BytesIO()
            img.save(img_byte_arr, format='PNG')  # Zawsze zwracaj PNG dla spójności
            return Response(img_byte_arr.getvalue(), media_type="image/png")

        elif file_extension in [".mp4", ".mov", ".avi", ".mkv"]:
            # Generowanie miniaturki z wideo za pomocą ffmpeg
            thumbnail_dir = file_path.parent / ".thumbnails"
            thumbnail_dir.mkdir(exist_ok=True)
            thumbnail_filename = f"{file_path.stem}.png"
            thumbnail_path = thumbnail_dir / thumbnail_filename

            # Sprawdź, czy miniaturka już istnieje
            if not thumbnail_path.exists():
                # Użyj ffmpeg do wygenerowania miniaturki z 5 sekundy wideo
                # Możesz dostosować '-ss' (czas startu) i '-vframes' (ilość klatek)
                cmd = [
                    "ffmpeg",
                    "-i", str(file_path),
                    "-ss", "00:00:05",  # Weź klatkę z 5 sekundy
                    "-vframes", "1",
                    "-vf", f"scale={size}:-1", # Skaluj do szerokości 'size', wysokość auto
                    "-f", "image2",
                    "-y", # Nadpisz istniejący plik bez pytania
                    str(thumbnail_path)
                ]
                # print(f"Running FFmpeg command: {' '.join(cmd)}") # Dodaj to do debugowania
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, stderr = await process.communicate()

                if process.returncode != 0:
                    error_msg = stderr.decode()
                    # logger.error(f"FFmpeg error: {error_msg}") # Użyj, jeśli masz logger
                    print(f"FFmpeg error: {error_msg}") # Wypisz do konsoli
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail="Could not generate video thumbnail: " + error_msg
                    )

            if not thumbnail_path.exists():
                # logger.error("Thumbnail generation failed unexpectedly, file not found after FFmpeg.")
                print("Thumbnail generation failed unexpectedly, file not found after FFmpeg.")
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail="Thumbnail generation failed unexpectedly"
                )

            # Zwróć wygenerowaną miniaturkę
            return FileResponse(thumbnail_path, media_type="image/png")
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Unsupported file type for thumbnail generation"
            )

    except HTTPException as http_exc:
        raise http_exc
    except FileNotFoundError:
        # To złapie błąd, jeśli 'ffmpeg' nie zostanie znaleziony w PATH
        # logger.error("FFmpeg command not found. Is FFmpeg installed and in your system's PATH?")
        print("FFmpeg command not found. Is FFmpeg installed and in your system's PATH?")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="FFmpeg is not installed or not in system PATH. Cannot generate video thumbnails."
        )
    except Exception as e:
        # logger.error(f"Error generating thumbnail for {filename}: {str(e)}")
        print(f"Error generating thumbnail for {filename}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating thumbnail: {str(e)}"
        )


@router.get("/{location_id}/devices/{device_id}/thumbnail", response_class=FileResponse)
async def generate_and_get_thumbnail(location_id: str, device_id: str, db=Depends(get_database), size: int = 128):
    """
    Generuje i zwraca miniaturkę wideo urządzenia, zapisując ją w polu `thumbnail`.
    """
    try:
        if not ObjectId.is_valid(location_id) or not ObjectId.is_valid(device_id):
            raise HTTPException(status_code=400, detail="Invalid ID format")

        location = await db["locations"].find_one({"_id": ObjectId(location_id)})
        if not location:
            raise HTTPException(status_code=404, detail="Location not found")

        devices = location.get("devices", [])
        target_device = next((d for d in devices if str(d["_id"]) == device_id), None)

        if not target_device:
            raise HTTPException(status_code=404, detail="Device not found")

        video_filename = target_device.get("video")
        if not video_filename:
            raise HTTPException(status_code=400, detail="Device has no video")

        video_path = Path(UPLOAD_DIR) / location_id / video_filename
        if not video_path.exists():
            raise HTTPException(status_code=404, detail="Video file not found")

        # Generuj ścieżkę miniaturki
        thumbnail_dir = video_path.parent / ".thumbnails"
        thumbnail_dir.mkdir(exist_ok=True)
        thumbnail_filename = f"{video_path.stem}.png"
        thumbnail_path = thumbnail_dir / thumbnail_filename

        if not thumbnail_path.exists():
            cmd = [
                "ffmpeg",
                "-i", str(video_path),
                "-ss", "00:00:05",
                "-vframes", "1",
                "-vf", f"scale={size}:-1",
                "-f", "image2",
                "-y",
                str(thumbnail_path)
            ]
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            _, stderr = await process.communicate()

            if process.returncode != 0:
                raise HTTPException(
                    status_code=500,
                    detail="Failed to generate thumbnail: " + stderr.decode()
                )

        # Zapisz miniaturkę w polu `thumbnail` (jeśli jeszcze nie była zapisana)
        relative_path = f"{location_id}/.thumbnails/{thumbnail_filename}"
        if target_device.get("thumbnail") != relative_path:
            target_device["thumbnail"] = relative_path
            await db["locations"].update_one(
                {"_id": ObjectId(location_id)},
                {"$set": {"devices": devices}}
            )

        return FileResponse(thumbnail_path, media_type="image/png")

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Thumbnail error: {str(e)}")





@router.put("/{location_id}/devices/{device_id}/thumbnail", status_code=200)
async def update_device_thumbnail(
    location_id: str,
    device_id: str,
    body: dict,
    db=Depends(get_database)
):
    """
    Ręcznie ustawia ścieżkę miniaturki (`thumbnail`) dla danego urządzenia
    """
    thumbnail = body.get("thumbnail")
    if not thumbnail:
        raise HTTPException(status_code=400, detail="Missing 'thumbnail' field in body")

    return await _update_device_field(location_id, device_id, {"thumbnail": thumbnail}, db)


@router.delete("/{location_id}/devices", status_code=200)
async def remove_all_devices_from_location(location_id: str, db=Depends(get_database)):
    """
    Usuwa wszystkie urządzenia z lokalizacji
    """
    try:
        if not ObjectId.is_valid(location_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid location ID format"
            )

        location = await db["locations"].find_one({"_id": ObjectId(location_id)})
        if not location:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Location not found"
            )

        result = await db["locations"].update_one(
            {"_id": ObjectId(location_id)},
            {"$set": {"devices": []}}
        )

        if result.modified_count == 0:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Devices were not removed"
            )

        return {"message": f"All devices removed from location {location_id}"}

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error removing devices: {str(e)}"
        )


from fastapi import status

@router.delete("/{location_id}/files/{filename}", status_code=status.HTTP_200_OK)
async def delete_file_from_location(location_id: str, filename: str):
    """
    Usuwa fizyczny plik z lokalizacji (i opcjonalnie także miniaturkę, jeśli istnieje).
    """
    try:
        file_path = UPLOAD_DIR / location_id / filename
        thumbnail_path = UPLOAD_DIR / location_id / ".thumbnails" / f"{Path(filename).stem}.png"

        # Sprawdź czy plik istnieje
        if not file_path.exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plik nie istnieje"
            )

        # Usuń plik
        file_path.unlink()

        # Usuń miniaturkę, jeśli istnieje
        if thumbnail_path.exists():
            thumbnail_path.unlink()

        return {
            "message": f"Plik {filename} został usunięty",
            "location_id": location_id
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Błąd podczas usuwania pliku: {str(e)}"
        )


@router.put("/{location_id}/devices/{device_id}/online", status_code=200)
async def set_device_online(location_id: str, device_id: str, db=Depends(get_database)):
    """
    Ustawia isOnline = true dla danego urządzenia
    """
    return await _update_device_field(location_id, device_id, {"isOnline": True}, db)

@router.put("/{location_id}/devices/{device_id}/offline", status_code=200)
async def set_device_offline(location_id: str, device_id: str, db=Depends(get_database)):
    """
    Ustawia isOnline = false dla danego urządzenia
    """
    return await _update_device_field(location_id, device_id, {"isOnline": False}, db)


@router.put("/{location_id}/devices/{device_id}/ip", status_code=200)
async def update_device_ip(
    location_id: str,
    device_id: str,
    body: dict,
    db=Depends(get_database)
):
    """
    Ustawia/IP aktualizuje pole `ip` dla wskazanego urządzenia (po _id urządzenia).
    Przykład body: { "ip": "192.168.68.201" }
    """
    ip = body.get("ip")
    if not ip:
        raise HTTPException(status_code=400, detail="Missing 'ip' field in body")

    # (opcjonalnie) prosta walidacja IPv4
    import re
    if not re.fullmatch(r"(?:\d{1,3}\.){3}\d{1,3}", ip):
        raise HTTPException(status_code=400, detail="Invalid IPv4 format")

    return await _update_device_field(location_id, device_id, {"ip": ip}, db)


mam taki api/users.py:
from fastapi import APIRouter, HTTPException, Depends, Request, status
from typing import List
from models import User, UserCreate, UserResponse, LocationIdsRequest, UserDevicesResponse, Device
from passlib.context import CryptContext
from bson import ObjectId
import logging

router = APIRouter()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
logger = logging.getLogger(__name__)

# Dependency to get database connection
def get_database(request: Request):
    return request.app.mongodb

# Password hashing
def hash_password(password: str) -> str:
    return pwd_context.hash(password)

# Create new user
@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate, db=Depends(get_database)):
    """
    Create a new user with hashed password
    """
    try:
        # Check if user already exists
        existing_user = await db["users"].find_one({"login": user.login})
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User with this login already exists"
            )

        # Hash password and create user
        hashed_password = hash_password(user.password)
        user_dict = user.dict()
        user_dict["password"] = hashed_password
        user_dict["_id"] = ObjectId()  # Generate new ObjectId

        result = await db["users"].insert_one(user_dict)

        # Get created user and convert _id to string
        created_user = await db["users"].find_one({"_id": result.inserted_id})
        created_user["_id"] = str(created_user["_id"])

        return UserResponse(**created_user)

    except Exception as e:
        logger.error(f"Error creating user: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating user: {str(e)}"
        )

# Get all users
@router.get("/", response_model=List[UserResponse])
async def get_users(db=Depends(get_database)):
    """
    Get list of all users
    """
    try:
        users = []
        async for user in db["users"].find():
            user["_id"] = str(user["_id"])  # Convert ObjectId to string
            users.append(UserResponse(**user))
        return users
    except Exception as e:
        logger.error(f"Error fetching users: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching users: {str(e)}"
        )

# Get single user by ID
@router.get("/{user_id}", response_model=UserResponse)
async def get_user(user_id: str, db=Depends(get_database)):
    """
    Get user by ID
    """
    try:
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid user ID format"
            )

        user = await db["users"].find_one({"_id": ObjectId(user_id)})
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        user["_id"] = str(user["_id"])  # Convert ObjectId to string
        return UserResponse(**user)

    except Exception as e:
        logger.error(f"Error fetching user: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching user: {str(e)}"
        )

# Add locations to user
@router.put("/{user_id}/locations", response_model=UserResponse)
async def add_locations_to_user(
    user_id: str, 
    location_ids_request: LocationIdsRequest, 
    db=Depends(get_database)
):
    """
    Add locations to a user
    """
    try:
        location_ids = location_ids_request.location_ids

        # Validate user ID
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid user ID format"
            )
        
        # Check if user exists
        user = await db["users"].find_one({"_id": ObjectId(user_id)})
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        # Validate location IDs
        for location_id in location_ids:
            if not ObjectId.is_valid(location_id):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid location ID format: {location_id}"
                )
            location = await db["locations"].find_one({"_id": ObjectId(location_id)})
            if not location:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"Location with ID {location_id} not found"
                )

        # Add locations to user
        result = await db["users"].update_one(
            {"_id": ObjectId(user_id)},
            {"$addToSet": {"locations": {"$each": location_ids}}}
        )

        if result.matched_count == 0:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found after update attempt"
            )

        # Return updated user
        updated_user = await db["users"].find_one({"_id": ObjectId(user_id)})
        updated_user["_id"] = str(updated_user["_id"])
        return UserResponse(**updated_user)

    except Exception as e:
        logger.error(f"Error updating user locations: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating user locations: {str(e)}"
        )

# Get all devices from user's locations
@router.get("/{user_id}/devices", response_model=UserDevicesResponse)
async def get_user_devices(user_id: str, db=Depends(get_database)):
    """
    Get all devices from all locations assigned to a user
    """
    try:
        # Validate user ID
        if not ObjectId.is_valid(user_id):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid user ID format"
            )

        # Get user document
        user = await db["users"].find_one({"_id": ObjectId(user_id)})
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        # Get user's location IDs
        location_ids = user.get("locations", [])
        if not location_ids:
            return UserDevicesResponse(
                user_id=user_id,
                login=user["login"],
                devices=[]
            )

        # Convert string location IDs to ObjectId
        location_object_ids = [ObjectId(loc_id) for loc_id in location_ids]

        # Find all locations that belong to the user
        locations_cursor = db["locations"].find({"_id": {"$in": location_object_ids}})
        locations = await locations_cursor.to_list(length=None)

        # Collect all devices from all locations
        all_devices = []
        for location in locations:
            devices = location.get("devices", [])
            # Convert device _id to string if it exists
            for device in devices:
                if "_id" in device and isinstance(device["_id"], ObjectId):
                    device["_id"] = str(device["_id"])
            all_devices.extend(devices)

        return UserDevicesResponse(
            user_id=user_id,
            login=user["login"],
            devices=all_devices
        )

    except Exception as e:
        logger.error(f"Error fetching user devices: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching user devices: {str(e)}"
        )mam taki api/groups.py:
from fastapi import APIRouter, HTTPException, status, Request, Depends
from bson import ObjectId
from pydantic import BaseModel, Field
from typing import List, Optional

router = APIRouter()

def get_database(request: Request):
    return request.app.mongodb

# ➕ Model grupy
class GroupCreate(BaseModel):
    name: str
    description: Optional[str] = None

class GroupResponse(BaseModel):
    id: str = Field(..., alias="_id")
    location_id: str
    name: str
    description: Optional[str]

# 1. POST /locations/{location_id}/groups – dodaj grupę
@router.post("/locations/{location_id}/groups", response_model=GroupResponse)
async def create_group(location_id: str, group: GroupCreate, db=Depends(get_database)):
    if not ObjectId.is_valid(location_id):
        raise HTTPException(400, detail="Invalid location_id")

    group_doc = {
        "location_id": ObjectId(location_id),
        "name": group.name,
        "description": group.description
    }
    result = await db["groups"].insert_one(group_doc)
    group_doc["_id"] = str(result.inserted_id)
    group_doc["location_id"] = str(group_doc["location_id"])
    return GroupResponse(**group_doc)


# 2. GET /locations/{location_id}/groups – pobierz wszystkie grupy
@router.get("/locations/{location_id}/groups", response_model=List[GroupResponse])
async def get_groups(location_id: str, db=Depends(get_database)):
    groups_cursor = db["groups"].find({"location_id": ObjectId(location_id)})
    groups = []
    async for group in groups_cursor:
        group["_id"] = str(group["_id"])
        group["location_id"] = str(group["location_id"])
        groups.append(GroupResponse(**group))
    return groups

# 3. POST /locations/{location_id}/devices/{device_id}/groups – dodaj grupę do urządzenia
@router.post("/locations/{location_id}/devices/{device_id}/groups")
async def add_device_to_group(location_id: str, device_id: str, body: dict, db=Depends(get_database)):
    group_id = body.get("group_id")
    if not ObjectId.is_valid(group_id):
        raise HTTPException(400, detail="Invalid group_id")

    result = await db["locations"].update_one(
        {"_id": ObjectId(location_id), "devices._id": device_id},  # ✅ zakłada string
        {"$addToSet": {"devices.$.groups": ObjectId(group_id)}}
    )

    if result.matched_count == 0:
        raise HTTPException(404, detail="Device or location not found")

    return {"message": "Group added to device"}

# 4. GET /locations/{location_id}/groups/{group_id}/devices – urządzenia przypisane do grupy
@router.get("/locations/{location_id}/groups/{group_id}/devices")
async def get_devices_in_group(location_id: str, group_id: str, db=Depends(get_database)):
    location = await db["locations"].find_one({"_id": ObjectId(location_id)})
    if not location:
        raise HTTPException(404, detail="Location not found")

    devices = [
        d for d in location.get("devices", [])
        if group_id in [str(g) for g in d.get("groups", [])]
    ]
    for d in devices:
        d["_id"] = str(d["_id"])
    return devices

# 5. DELETE /locations/{location_id}/devices/{device_id}/groups/{group_id} – usuń grupę z urządzenia
@router.delete("/locations/{location_id}/devices/{device_id}/groups/{group_id}")
async def remove_device_from_group(location_id: str, device_id: str, group_id: str, db=Depends(get_database)):
    result = await db["locations"].update_one(
        {"_id": ObjectId(location_id), "devices._id": device_id},  # string, nie ObjectId!
        {"$pull": {"devices.$.groups": ObjectId(group_id)}}
    )

    if result.matched_count == 0:
        raise HTTPException(404, detail="Device or location not found")

    return {"message": "Group removed from device"}

# 6. DELETE /locations/{location_id}/groups/{group_id} – usuń grupę
@router.delete("/locations/{location_id}/groups/{group_id}")
async def delete_group(location_id: str, group_id: str, db=Depends(get_database)):
    # Usuń grupę z kolekcji groups
    delete_result = await db["groups"].delete_one({
        "_id": ObjectId(group_id),
        "location_id": ObjectId(location_id)
    })

    if delete_result.deleted_count == 0:
        raise HTTPException(404, detail="Group not found")

    # Usuń referencje z urządzeń
    await db["locations"].update_many(
        {"_id": ObjectId(location_id)},
        {"$pull": {"devices.$[].groups": ObjectId(group_id)}}
    )

    return {"message": "Group deleted and removed from devices"}
