import React, { useState, useRef } from "react";
import { Rnd } from "react-rnd";
import styles from "./Editor.module.css";
import Navbar from "./Navbar";
import { useNavigate } from "react-router-dom";

const API_BASE_URL = `${import.meta.env.VITE_BACKEND_URL}/api/locations`;

const getCurrentLocationId = () => {
  const storedUser = localStorage.getItem("user");
  const parsedUser = storedUser ? JSON.parse(storedUser) : null;
  const initialLocationIds = (() => {
    try {
      const arr = JSON.parse(localStorage.getItem("locationIds") || "[]");
      if (Array.isArray(arr) && arr.length > 0) return arr;
    } catch {}
    const legacy = localStorage.getItem("locationId");
    if (legacy) return [legacy];
    if (parsedUser?.locationIds && Array.isArray(parsedUser.locationIds) && parsedUser.locationIds.length > 0) {
      return parsedUser.locationIds;
    }
    return [];
  })();
  const legacyId = localStorage.getItem("locationId");
  return legacyId || (initialLocationIds.length > 0 ? initialLocationIds[0] : null);
};

function Editor() {
  const navigate = useNavigate();
  const [file, setFile] = useState(null);
  const [previewUrl, setPreviewUrl] = useState(null);
  const [isUploading, setIsUploading] = useState(false);
  const [errorMsg, setErrorMsg] = useState(null);
  const [fileName, setFileName] = useState("");

  const [elements, setElements] = useState([]);
  const [newText, setNewText] = useState("");
  const [newColor, setNewColor] = useState("#ff0000");
  const [newFontSize, setNewFontSize] = useState(24);

  const [editingElementId, setEditingElementId] = useState(null);
  const [editingElement, setEditingElement] = useState({ type: "", content: "", color: "", fontSize: 24 });

  const editorRef = useRef(null);
  const currentLocationId = getCurrentLocationId();

  const getFileType = (filename) => {
    const ext = (filename || "").split(".").pop().toLowerCase();
    if (["jpg","jpeg","png","gif","bmp","webp"].includes(ext)) return "image";
    if (["mp4","mov","avi","mkv","webm"].includes(ext)) return "video";
    return "unknown";
  };

  const handleFileChange = (e) => {
    setErrorMsg(null);
    if (e.target.files.length > 0) {
      const selectedFile = e.target.files[0];
      setFile(selectedFile);
      setPreviewUrl(URL.createObjectURL(selectedFile));
      setElements([]);
      setFileName(selectedFile.name.split(".")[0]);
    }
  };

  const handleAddText = () => {
    if (!newText.trim() || !newFontSize) return;
    setElements([
      ...elements,
      {
        id: Date.now(),
        type: "text",
        content: newText,
        color: newColor,
        width: 100,
        height: 50,
        x: 10,
        y: 10,
        fontSize: newFontSize,
      },
    ]);
    setNewText("");
  };

  const handleAddShape = (shapeType) => {
    setElements([
      ...elements,
      {
        id: Date.now(),
        type: "shape",
        shape: shapeType,
        color: newColor,
        width: 100,
        height: 100,
        x: 10,
        y: 10,
      },
    ]);
  };

  const handleElementClick = (el) => {
    setEditingElementId(el.id);
    setEditingElement({
      type: el.type,
      content: el.content || "",
      color: el.color,
      fontSize: el.fontSize || 24
    });
  };

  const handleUpdateElement = () => {
    setElements(elements.map(e => e.id === editingElementId
      ? { ...e, color: editingElement.color, content: editingElement.content, fontSize: editingElement.fontSize }
      : e
    ));
    setEditingElementId(null);
  };

  const handleDeleteElement = () => {
    setElements(elements.filter(e => e.id !== editingElementId));
    setEditingElementId(null);
  };

  const drawStar = (ctx, cx, cy, spikes, outerRadius, innerRadius, color) => {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    const step = Math.PI / spikes;
    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;
      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  };

  const handleSaveAndUpload = async () => {
    if (!file || !currentLocationId || !fileName.trim()) {
      setErrorMsg("Brak pliku, lokalizacji lub nazwy.");
      return;
    }
  
    const fileType = getFileType(file.name);
    if (fileType === "video") { /* upload video jak wcześniej */ return; }
  
    const img = new Image();
    img.src = previewUrl;
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  
      // Pobieramy DOMowy obraz, żeby obliczyć faktyczny render w editorze
      const displayedImg = editorRef.current.querySelector("img");
      if (!displayedImg) return;
  
      const displayedWidth = displayedImg.clientWidth;
      const displayedHeight = displayedImg.clientHeight;
  
      // Offsety jeśli object-fit: contain dodaje marginesy
      const offsetX = (editorRef.current.clientWidth - displayedWidth) / 2;
      const offsetY = (editorRef.current.clientHeight - displayedHeight) / 2;
  
      const scaleX = canvas.width / displayedWidth;
      const scaleY = canvas.height / displayedHeight;
  
      elements.forEach(el => {
        const x = (el.x - offsetX) * scaleX;
        const y = (el.y - offsetY) * scaleY;
        const w = el.width * scaleX;
        const h = el.height * scaleY;
  
        if (el.type === "text") {
          ctx.fillStyle = el.color;
          ctx.font = `${el.fontSize * scaleX}px sans-serif`;
          ctx.textBaseline = "top";
          ctx.fillText(el.content, x, y);
        } else if (el.type === "shape") {
          ctx.fillStyle = el.color;
          switch (el.shape) {
            case "circle":
              ctx.beginPath();
              ctx.arc(x + w/2, y + h/2, w/2, 0, 2*Math.PI);
              ctx.fill();
              break;
            case "square":
              ctx.fillRect(x, y, w, h);
              break;
            case "star":
              drawStar(ctx, x + w/2, y + h/2, 5, w/2, w/4, el.color);
              break;
          }
        }
      });
  
      canvas.toBlob(async blob => {
        const formData = new FormData();
        formData.append("file", blob, `${fileName}.png`);
        setIsUploading(true);
        try {
          const res = await fetch(`${API_BASE_URL}/${currentLocationId}/upload-file/`, {
            method: "POST",
            body: formData,
          });
          if (!res.ok) throw new Error("Błąd uploadu pliku");
          alert("Plik zapisany w galerii z elementami!");
          navigate("/gallery");
        } catch (err) {
          setErrorMsg(err.message);
        } finally {
          setIsUploading(false);
        }
      });
    };
  };
  

  const isImage = file && getFileType(file.name) === "image";

  return (
    <>
      <Navbar />
      <div className={styles.container}>
        <h2 className={styles.title}>Edytor Plików dla Lokalizacji: {currentLocationId}</h2>

        {editingElementId && (
          <div className={styles.editTextPanel}>
            {editingElement.type === "text" && (
              <>
                <input type="text" value={editingElement.content} onChange={e => setEditingElement({ ...editingElement, content: e.target.value })} />
                <input type="number" value={editingElement.fontSize} onChange={e => setEditingElement({ ...editingElement, fontSize: Number(e.target.value) })} />
              </>
            )}
            <input type="color" value={editingElement.color} onChange={e => setEditingElement({ ...editingElement, color: e.target.value })} />
            <button onClick={handleUpdateElement}>Zapisz</button>
            <button onClick={handleDeleteElement} style={{ backgroundColor: "#dc3545" }}>Usuń</button>
          </div>
        )}

        <div className={styles.contentWrapper}>
          <div className={styles.editorControls}>
            <div className={styles.controlGroup}>
              <h4>1. Wybierz Plik</h4>
              <input type="file" onChange={handleFileChange} accept="image/*,video/*" className={styles.fileInput} />
              {file && <p>Wybrany plik: <strong>{file.name}</strong></p>}
            </div>

            {isImage && (
              <>
                <div className={styles.controlGroup}>
                  <h4>2. Dodaj Kształty</h4>
                  <div className={styles.shapeButtons}>
                    <button onClick={() => handleAddShape("circle")}>Okrąg</button>
                    <button onClick={() => handleAddShape("square")}>Kwadrat</button>
                    <button onClick={() => handleAddShape("star")}>Gwiazdka</button>
                  </div>
                  <input type="color" value={newColor} onChange={e => setNewColor(e.target.value)} />
                </div>

                <div className={styles.controlGroup}>
                  <h4>3. Dodaj Tekst</h4>
                  <input type="text" value={newText} onChange={e => setNewText(e.target.value)} placeholder="Tekst..." className={styles.textInput} />
                  <input type="number" value={newFontSize} onChange={e => setNewFontSize(Number(e.target.value))} placeholder="Rozmiar fontu" className={styles.textInput} />
                  <input type="color" value={newColor} onChange={e => setNewColor(e.target.value)} />
                  <button onClick={handleAddText} className={styles.addButton}>Dodaj Tekst</button>
                </div>
              </>
            )}

            {previewUrl && (
              <div className={styles.controlGroup}>
                <h4>4. Nazwa pliku</h4>
                <input type="text" value={fileName} onChange={e => setFileName(e.target.value)} placeholder="Nazwa pliku..." className={styles.textInput} />
              </div>
            )}

            <button onClick={handleSaveAndUpload} disabled={!previewUrl || isUploading} className={styles.saveButton}>
              {isUploading ? "Zapisywanie..." : "Zapisz i dodaj do galerii"}
            </button>

            {errorMsg && <div className={styles.errorMessage}>{errorMsg}</div>}
          </div>

          <div className={styles.editorArea} ref={editorRef}>
            {!previewUrl ? (
              <div className={styles.placeholder}>Wybierz plik, aby rozpocząć edycję</div>
            ) : (
              <div className={styles.editorCanvas}>
                {getFileType(file.name) === "image" ? (
                  <img src={previewUrl} alt="Edytowany" className={styles.mediaElement} />
                ) : getFileType(file.name) === "video" ? (
                  <video src={previewUrl} controls className={styles.mediaElement} />
                ) : (
                  <div>Nieobsługiwany typ pliku</div>
                )}

                {isImage && elements.map(el => (
                  <Rnd
                    key={el.id}
                    size={{ width: el.width, height: el.height }}
                    position={{ x: el.x, y: el.y }}
                    enableResizing={el.type === "shape"}
                    onDragStop={(e, d) => setElements(elements.map(e2 => e2.id === el.id ? { ...e2, x: d.x, y: d.y } : e2))}
                    onResizeStop={(e, direction, ref, delta, position) => {
                      setElements(elements.map(e2 => e2.id === el.id
                        ? { ...e2, width: parseInt(ref.style.width), height: parseInt(ref.style.height), x: position.x, y: position.y }
                        : e2));
                    }}
                    bounds="parent"
                  >
                    {el.type === "text" ? (
                      <div
                        style={{ color: el.color, fontSize: el.fontSize, fontWeight: "bold", cursor: "move", width: "100%", height: "100%" }}
                        onClick={() => handleElementClick(el)}
                      >
                        {el.content}
                      </div>
                    ) : (
                      <div
                        style={{
                          width: "100%", height: "100%",
                          backgroundColor: el.color,
                          borderRadius: el.shape === "circle" ? "50%" : "0",
                          cursor: "move"
                        }}
                        onClick={() => handleElementClick(el)}
                      />
                    )}
                  </Rnd>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    </>
  );
}

export default Editor;


jest problem - elementy/kształti i tekst dodają się przy zapisywaniu w galerii w złym miejscu - umieściłem prostokąt na samym dole, a w galerii w pliku fizycznym znalazł się po środku - zrób tak aby wszystkie elementy ZAWSZE znajdowały się w dobrym miejscu.

dodaje kwadrat w lewym dolnym rogu, a w fizycznym pliku dodaje się po lewej stronie ale pomniejszony i wyżej niż ustawiłem - naprawisz? 

poka cały kod